import { NextRequest, NextResponse } from "next/server";

export async function POST(req: NextRequest) {
  try {
    const { amount } = await req.json();

    if (!amount) {
      return NextResponse.json({ error: "Valor inv√°lido" }, { status: 400 });
    }

    const response = await fetch("POST https://api.ggcheckout.com/v1/transactions
"), {
      method: "POST",
      headers: {
        Authorization: `Bearer ${ggck_live_6e616e917a588e7d7291f4c1491b8d67e02f27a558fcc420215c53ca18490949}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        amount: amount,
        paymentMethod: "pix"
      }),
    });

    const data = await response.json();

    return NextResponse.json(data);

  } catch (error) {
    return NextResponse.json({ error: "Erro ao criar pagamento" }, { status: 500 });
  }
}

export interface DepositRequest {
  userId: string
  amount: number
  paymentMethod: 'pix'
}

export interface DepositResponse {
  success: boolean
  depositId: string
  pixCode?: string
  pixQRCode?: string
  amount: number
  expiresAt?: string
  message?: string
}

// In-memory storage for demo (replace with database)
const deposits = new Map<string, {
  id: string
  userId: string
  amount: number
  status: 'pending' | 'completed' | 'expired'
  pixCode: string
  createdAt: Date
  expiresAt: Date
}>()

export async function POST(request: NextRequest) {
  try {
    const body: DepositRequest = await request.json()
    
    const { userId, amount, paymentMethod } = body

    // Validation
    if (!userId || !amount || amount <= 0) {
      return NextResponse.json(
        { success: false, message: 'Invalid deposit data' },
        { status: 400 }
      )
    }

    if (paymentMethod !== 'pix') {
      return NextResponse.json(
        { success: false, message: 'Only PIX payment method is supported' },
        { status: 400 }
      )
    }

    // Generate deposit ID
    const depositId = `DEP${Date.now()}${Math.random().toString(36).substr(2, 9).toUpperCase()}`
    
    // Generate PIX code (in production, this would come from payment gateway)
    const pixCode = generatePixCode(amount, depositId)
    
    // Set expiration (15 minutes from now)
    const expiresAt = new Date(Date.now() + 15 * 60 * 1000)

    // Store deposit (in production, save to database)
    deposits.set(depositId, {
      id: depositId,
      userId,
      amount,
      status: 'pending',
      pixCode,
      createdAt: new Date(),
      expiresAt
    })

    // TODO: Integrate with payment gateway (Mercado Pago, PagSeguro, etc.)
    // Example:
    // const paymentGatewayResponse = await paymentGateway.createPixPayment({
    //   amount,
    //   userId,
    //   callbackUrl: `${process.env.NEXT_PUBLIC_APP_URL}/api/deposit/callback`
    // })

    console.log('[v0] Deposit created:', depositId, 'Amount:', amount, 'User:', userId)

    return NextResponse.json<DepositResponse>({
      success: true,
      depositId,
      pixCode,
      pixQRCode: `data:image/svg+xml;base64,${generateQRCodeSVG(pixCode)}`,
      amount,
      expiresAt: expiresAt.toISOString(),
    })
  } catch (error) {
    console.error('[v0] Deposit error:', error)
    return NextResponse.json(
      { success: false, message: 'Internal server error' },
      { status: 500 }
    )
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const depositId = searchParams.get('depositId')

    if (!depositId) {
      return NextResponse.json(
        { success: false, message: 'Deposit ID is required' },
        { status: 400 }
      )
    }

    const deposit = deposits.get(depositId)

    if (!deposit) {
      return NextResponse.json(
        { success: false, message: 'Deposit not found' },
        { status: 404 }
      )
    }

    // Check if expired
    if (new Date() > deposit.expiresAt && deposit.status === 'pending') {
      deposit.status = 'expired'
    }

    return NextResponse.json({
      success: true,
      deposit: {
        id: deposit.id,
        amount: deposit.amount,
        status: deposit.status,
        createdAt: deposit.createdAt,
        expiresAt: deposit.expiresAt
      }
    })
  } catch (error) {
    console.error('[v0] Get deposit error:', error)
    return NextResponse.json(
      { success: false, message: 'Internal server error' },
      { status: 500 }
    )
  }
}

// Helper function to generate PIX code
function generatePixCode(amount: number, depositId: string): string {
  // In production, this would be generated by the payment gateway
  // This is a simplified example
  const payload = `00020126580014BR.GOV.BCB.PIX0136${depositId}520400005303986540${amount.toFixed(2)}5802BR5925ROLETA MAGICA CASSINO6009SAO PAULO62070503***6304`
  return payload + generateCRC16(payload)
}

// Helper function to generate CRC16 for PIX code
function generateCRC16(payload: string): string {
  // Simplified CRC16 (in production, use proper implementation)
  let crc = 0xFFFF
  for (let i = 0; i < payload.length; i++) {
    crc ^= payload.charCodeAt(i) << 8
    for (let j = 0; j < 8; j++) {
      crc = (crc & 0x8000) ? (crc << 1) ^ 0x1021 : crc << 1
    }
  }
  return (crc & 0xFFFF).toString(16).toUpperCase().padStart(4, '0')
}

// Helper function to generate QR Code SVG (base64)
function generateQRCodeSVG(data: string): string {
  // In production, use a proper QR code library like 'qrcode'
  // This is a placeholder that creates a simple pattern
  const size = 200
  const cellSize = 4
  const cells = Math.floor(size / cellSize)
  
  let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">`
  svg += `<rect width="${size}" height="${size}" fill="white"/>`
  
  // Generate pseudo-random pattern based on data
  for (let i = 0; i < cells; i++) {
    for (let j = 0; j < cells; j++) {
      const hash = (data.charCodeAt(i % data.length) + i * j) % 2
      if (hash === 0) {
        svg += `<rect x="${j * cellSize}" y="${i * cellSize}" width="${cellSize}" height="${cellSize}" fill="black"/>`
      }
    }
  }
  
  svg += '</svg>'
  return Buffer.from(svg).toString('base64')
}
